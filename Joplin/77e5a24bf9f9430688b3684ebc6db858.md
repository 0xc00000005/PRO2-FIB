id: 77e5a24bf9f9430688b3684ebc6db858
parent_id: 
item_type: 1
item_id: 24a755f4e24940598ecd070edd26e7b3
item_updated_time: 1726739290752
title_diff: "[{\"diffs\":[[1,\"Clase 2: stack y queue\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":22}]"
body_diff: "[{\"diffs\":[[1,\"## Resumen de la clase `Stack` (Pila)\\\n\\\nEn C++, una pila (*stack*) es una estructura de datos lineal que sigue el principio **LIFO** (Last In, First Out), es decir, el último elemento insertado es el primero en ser removido. Se puede imaginar como una pila de platos donde el último en ser colocado es el primero en ser retirado.\\\n\\\n### Especificación de la clase `stack`\\\n\\\nLa clase `stack` es una clase genérica (*template*) que puede almacenar elementos de cualquier tipo. A continuación, se presenta la especificación básica:\\\n\\\n```cpp\\\ntemplate <class T>\\\nclass stack {\\\n    // Constructores\\\n    stack();                           // Constructor por defecto\\\n    stack(const stack& original);      // Constructor de copia\\\n\\\n    // Modificadores\\\n    void push(const T& x);             // Añade un elemento a la pila\\\n    void pop();                        // Remueve el último elemento\\\n\\\n    // Consultores\\\n    T top() const;                     // Retorna el último elemento sin removerlo\\\n    bool empty() const;                // Verifica si la pila está vacía\\\n    int size() const;                  // Retorna el número de elementos en la pila\\\n};\\\n```\\\n\\\n### Operaciones principales\\\n\\\n1. **`push(const T& x)`**:\\\n   Inserta el elemento `x` en la parte superior de la pila.\\\n   ```cpp\\\n   stack<int> p;\\\n   p.push(5); // La pila ahora contiene: [5]\\\n   p.push(10); // La pila ahora contiene: [5, 10]\\\n   ```\\\n\\\n2. **`pop()`**:\\\n   Elimina el elemento en la parte superior de la pila. Este método no retorna el valor removido.\\\n   ```cpp\\\n   p.pop(); // Elimina el 10, la pila ahora contiene: [5]\\\n   ```\\\n\\\n3. **`top()`**:\\\n   Retorna el elemento que está en la parte superior de la pila sin removerlo.\\\n   ```cpp\\\n   int valor = p.top(); // valor es 5\\\n   ```\\\n\\\n4. **`empty()`**:\\\n   Retorna `true` si la pila está vacía, y `false` en caso contrario.\\\n   ```cpp\\\n   bool vacia = p.empty(); // vacia es false\\\n   ```\\\n\\\n5. **`size()`**:\\\n   Retorna el número de elementos almacenados en la pila.\\\n   ```cpp\\\n   int tamano = p.size(); // tamano es 1\\\n   ```\\\n\\\n### Ejemplo de uso\\\n\\\nSupongamos que tenemos una pila para almacenar enteros. Queremos añadir varios valores, verificar cuál es el último añadido, y finalmente vaciar la pila.\\\n\\\n```cpp\\\n#include <stack>\\\n#include <iostream>\\\n\\\nint main() {\\\n    std::stack<int> pila;\\\n\\\n    // Agregar elementos\\\n    pila.push(1);\\\n    pila.push(2);\\\n    pila.push(3);\\\n\\\n    std::cout << \\\"Tamaño de la pila: \\\" << pila.size() << std::endl;\\\n    std::cout << \\\"Elemento superior: \\\" << pila.top() << std::endl;\\\n\\\n    // Eliminar elementos\\\n    while (!pila.empty()) {\\\n        std::cout << \\\"Eliminando: \\\" << pila.top() << std::endl;\\\n        pila.pop();\\\n    }\\\n\\\n    std::cout << \\\"Pila vacía: \\\" << std::boolalpha << pila.empty() << std::endl;\\\n    return 0;\\\n}\\\n```\\\n\\\n### Ejemplo práctico: Evaluación de una expresión en notación postfija\\\n\\\nUno de los usos típicos de una pila es la evaluación de expresiones aritméticas en notación postfija (RPN). En este caso, podemos usar una pila para almacenar resultados intermedios mientras procesamos los operadores y operandos.\\\n\\\n```cpp\\\nint evalPostfix(const std::string& expr) {\\\n    std::stack<int> pila;\\\n\\\n    for (char c : expr) {\\\n        if (isdigit(c)) {\\\n            pila.push(c - '0'); // Convierte el carácter en número\\\n        } else {\\\n            int val2 = pila.top(); pila.pop();\\\n            int val1 = pila.top(); pila.pop();\\\n\\\n            switch (c) {\\\n                case '+': pila.push(val1 + val2); break;\\\n                case '*': pila.push(val1 * val2); break;\\\n            }\\\n        }\\\n    }\\\n\\\n    return pila.top(); // El resultado final está en la cima de la pila\\\n}\\\n```\\\n\\\nPor ejemplo, la expresión `\\\"35+24+*\\\"` se evaluaría de la siguiente manera:\\\n1. Push de 3 y 5.\\\n2. Suma de 3 y 5 → Push de 8.\\\n3. Push de 2 y 4.\\\n4. Suma de 2 y 4 → Push de 6.\\\n5. Multiplicación de 8 y 6 → Push de 48.\\\n\\\nResultado final: 48.\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":3832}]"
metadata_diff: {"new":{"id":"24a755f4e24940598ecd070edd26e7b3","parent_id":"8c99ee77d84c400c9c7968dff4a154ec","latitude":"41.38506390","longitude":"2.17340350","altitude":"0.0000","author":"","source_url":"","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":0,"markup_language":1,"is_shared":0,"share_id":"","conflict_original_id":"","master_key_id":"","user_data":"","deleted_time":0},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2024-09-19T09:49:59.622Z
created_time: 2024-09-19T09:49:59.622Z
type_: 13