id: a75732bbc0a6426aa2eb827e68f680b2
parent_id: 
item_type: 1
item_id: d6d71a534b5a4f99ade559dc21bb3435
item_updated_time: 1726738808693
title_diff: "[{\"diffs\":[[1,\"Clase 1: Classes\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":16}]"
body_diff: "[{\"diffs\":[[1,\"Es importante limitar las dependencias para hacer un código modular y que un cambio no afecte al resto.\\\n## Módulos\\\nSon \\\"cajas negras\\\" con muchos detalles internos.\\\nSi se especifican bien funciones, no se necesitan saber sus detalles, sólo su *Pre* (condición que tienen que cumplir los parámetros), *Post* (condición que tiene que cumplir el resultado).\\\n\\\n## Tipos abractos de datos\\\nAsociar un struct o tupla con la función que la usa. Esto se implementa con la ayuda de clases.\\\n### Clases\\\nLas funciones asociadas a una clase se llaman métodos. Los objetos son los valores o variables de una clase.\\\n``` cpp\\\n#include <iostream>\\\nusing namespace std;\\\n\\\n// Definición de la clase Persona\\\nclass Persona {\\\nprivate:\\\n    string nombre;\\\n    int edad;\\\n\\\npublic:\\\n    // Constructor de la clase\\\n    Persona(string n, int e) {\\\n        nombre = n;\\\n        edad = e;\\\n    }\\\n\\\n    // Método para mostrar la información de la persona\\\n    void mostrarInformacion() {\\\n        cout << \\\"Nombre: \\\" << nombre << \\\", Edad: \\\" << edad << endl;\\\n    }\\\n\\\n    // Método para cambiar la edad de la persona\\\n    void cambiarEdad(int nuevaEdad) {\\\n        edad = nuevaEdad;\\\n    }\\\n};\\\n\\\nint main() {\\\n    // Creación de un objeto de la clase Persona\\\n    Persona persona1(\\\"Juan\\\", 25);\\\n\\\n    // Uso del método mostrarInformacion\\\n    persona1.mostrarInformacion();\\\n\\\n    // Cambio de la edad usando el método cambiarEdad\\\n    persona1.cambiarEdad(30);\\\n\\\n    // Mostrar la información actualizada\\\n    persona1.mostrarInformacion();\\\n\\\n    return 0;\\\n}\\\n```\\\n### Parámetro implícito\\\nNormalmente, al llamar una función se pasan variables. Al operar con objetos, muchas veces no es necesario hacerlo porque se sobreentienden los parámetros, ya que el objeto tiene este tipo de información en su especificación.\\\nEjemplo para aclarar:\\\n```\\\nb=est.tiene_nota();\\\n// Parámetro nota definido en la clase.\\\n```\\\n### Constructores y consultores\\\nEn C++, un constructor es un método especial que se llama automáticamente al crear un objeto. Su función es inicializar los atributos de la clase. Similar a cuando declaras un *int*, pero conceptualmente diferente.\\\n\\\nUn método consultor (o accesor) es una función miembro que permite acceder al valor de un atributo privado de la clase sin modificarlo. Se suele declarar como const.\\\n\\\n### Métodos de clase\\\nUn método de clase en C++ es un método estático, lo que significa que pertenece a la clase en sí y no a instancias específicas de esa clase. Esto permite que el método sea invocado sin crear un objeto de la clase.\\\nCaracterísticas clave:\\\n\\\n- Se declara con la palabra clave static.\\\n- Puede acceder únicamente a miembros estáticos de la clase, ya que no tiene acceso a datos específicos de los objetos.\\\n- No necesita una instancia (objeto) para ser llamado.\\\n\\\n``` cpp\\\nclass Ejemplo {\\\npublic:\\\n    static int contador;  // Variable de clase (compartida por todos los objetos)\\\n    int valor;            // Variable de objeto (cada objeto tiene su propia copia)\\\n\\\n    Ejemplo(int v) : valor(v) {\\\n        contador++; // Incrementa el contador cada vez que se crea un objeto\\\n    }\\\n\\\n    static int getContador() {  // Método de clase\\\n        return contador;\\\n    }\\\n\\\n    int getValor() const {  // Método de objeto\\\n        return valor;\\\n    }\\\n};\\\n\\\n// Inicialización de la variable estática fuera de la clase\\\nint Ejemplo::contador = 0;\\\n\\\nint main() {\\\n    // Crear dos objetos\\\n    Ejemplo obj1(10);\\\n    Ejemplo obj2(20);\\\n\\\n    // Acceder a la variable de objeto\\\n    std::cout << \\\"Valor de obj1: \\\" << obj1.getValor() << std::endl; // Salida: 10\\\n    std::cout << \\\"Valor de obj2: \\\" << obj2.getValor() << std::endl; // Salida: 20\\\n\\\n    // Acceder a la variable de clase (es la misma para ambos objetos)\\\n    std::cout << \\\"Contador (compartido): \\\" << Ejemplo::getContador() << std::endl; // Salida: 2\\\n}\\\n\\\n```\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":3757}]"
metadata_diff: {"new":{"id":"d6d71a534b5a4f99ade559dc21bb3435","parent_id":"8c99ee77d84c400c9c7968dff4a154ec","latitude":"40.44752720","longitude":"-3.80741520","altitude":"0.0000","author":"","source_url":"","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":0,"markup_language":1,"is_shared":0,"share_id":"","conflict_original_id":"","master_key_id":"","user_data":"","deleted_time":0},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2024-09-19T09:49:59.592Z
created_time: 2024-09-19T09:49:59.592Z
type_: 13