Clase 2: stack y queue

## Resumen de la clase `Stack` (Pila)

En C++, una pila (*stack*) es una estructura de datos lineal que sigue el principio **LIFO** (Last In, First Out), es decir, el último elemento insertado es el primero en ser removido. Se puede imaginar como una pila de platos donde el último en ser colocado es el primero en ser retirado.

### Especificación de la clase `stack`

La clase `stack` es una clase genérica (*template*) que puede almacenar elementos de cualquier tipo. A continuación, se presenta la especificación básica:

```cpp
template <class T>
class stack {
    // Constructores
    stack();                           // Constructor por defecto
    stack(const stack& original);      // Constructor de copia

    // Modificadores
    void push(const T& x);             // Añade un elemento a la pila
    void pop();                        // Remueve el último elemento

    // Consultores
    T top() const;                     // Retorna el último elemento sin removerlo
    bool empty() const;                // Verifica si la pila está vacía
    int size() const;                  // Retorna el número de elementos en la pila
};
```

### Operaciones principales

1. **`push(const T& x)`**:
   Inserta el elemento `x` en la parte superior de la pila.
   ```cpp
   stack<int> p;
   p.push(5); // La pila ahora contiene: [5]
   p.push(10); // La pila ahora contiene: [5, 10]
   ```

2. **`pop()`**:
   Elimina el elemento en la parte superior de la pila. Este método no retorna el valor removido.
   ```cpp
   p.pop(); // Elimina el 10, la pila ahora contiene: [5]
   ```

3. **`top()`**:
   Retorna el elemento que está en la parte superior de la pila sin removerlo.
   ```cpp
   int valor = p.top(); // valor es 5
   ```

4. **`empty()`**:
   Retorna `true` si la pila está vacía, y `false` en caso contrario.
   ```cpp
   bool vacia = p.empty(); // vacia es false
   ```

5. **`size()`**:
   Retorna el número de elementos almacenados en la pila.
   ```cpp
   int tamano = p.size(); // tamano es 1
   ```

### Ejemplo de uso

Supongamos que tenemos una pila para almacenar enteros. Queremos añadir varios valores, verificar cuál es el último añadido, y finalmente vaciar la pila.

```cpp
#include <stack>
#include <iostream>

int main() {
    std::stack<int> pila;

    // Agregar elementos
    pila.push(1);
    pila.push(2);
    pila.push(3);

    std::cout << "Tamaño de la pila: " << pila.size() << std::endl;
    std::cout << "Elemento superior: " << pila.top() << std::endl;

    // Eliminar elementos
    while (!pila.empty()) {
        std::cout << "Eliminando: " << pila.top() << std::endl;
        pila.pop();
    }

    std::cout << "Pila vacía: " << std::boolalpha << pila.empty() << std::endl;
    return 0;
}
```

### Ejemplo práctico: Evaluación de una expresión en notación postfija

Uno de los usos típicos de una pila es la evaluación de expresiones aritméticas en notación postfija (RPN). En este caso, podemos usar una pila para almacenar resultados intermedios mientras procesamos los operadores y operandos.

```cpp
int evalPostfix(const std::string& expr) {
    std::stack<int> pila;

    for (char c : expr) {
        if (isdigit(c)) {
            pila.push(c - '0'); // Convierte el carácter en número
        } else {
            int val2 = pila.top(); pila.pop();
            int val1 = pila.top(); pila.pop();

            switch (c) {
                case '+': pila.push(val1 + val2); break;
                case '*': pila.push(val1 * val2); break;
            }
        }
    }

    return pila.top(); // El resultado final está en la cima de la pila
}
```

### Véase: Notaciones
La notación posfija se menciona ya que es un tipo de notación alternativa a la algebraica que evita ambiguedades en el orden de operaciones. Al inicio talvez se ve un poco complejo, pero no es así; lo que hace el lenguaje es colocar primero los números con los que va a operar y luego escribe la operación, por ejemplo $a+b$ se escribiría "$a$ $b$ +''; $(5-8)*4$ se escribiría "5 8 - 4 *'', otros ejemplos son:
![24f96b924c870cd46fc59567e85cc368.png](:/825304be51bc4446ae1474e733ffc61d)

## Resumen de la clase `Queue` (Cua)

En C++, una cola (*queue*) es una estructura de datos lineal que sigue el principio **FIFO** (First In, First Out), lo que significa que el primer elemento en entrar es el primero en salir. Un ejemplo típico es una fila de personas donde la primera persona en llegar es la primera en ser atendida.

### Especificación de la clase `queue`

La clase `queue` es una clase genérica (*template*) que puede almacenar elementos de cualquier tipo. A continuación, se presenta la especificación básica:

```cpp
template <class T>
class queue {
    // Constructores
    queue();                            // Constructor por defecto
    queue(const queue& original);       // Constructor de copia

    // Modificadores
    void push(const T& x);              // Añade un elemento al final de la cola
    void pop();                         // Elimina el primer elemento de la cola

    // Consultores
    T front() const;                    // Retorna el primer elemento sin eliminarlo
    bool empty() const;                 // Verifica si la cola está vacía
    int size() const;                   // Retorna el número de elementos en la cola
};
```

### Operaciones principales

1. **`push(const T& x)`**:
   Inserta el elemento `x` al final de la cola.
   ```cpp
   queue<int> c;
   c.push(5); // La cola ahora contiene: [5]
   c.push(10); // La cola ahora contiene: [5, 10]
   ```

2. **`pop()`**:
   Elimina el primer elemento de la cola. Este método no retorna el valor removido.
   ```cpp
   c.pop(); // Elimina el 5, la cola ahora contiene: [10]
   ```

3. **`front()`**:
   Retorna el primer elemento sin eliminarlo.
   ```cpp
   int valor = c.front(); // valor es 10
   ```

4. **`empty()`**:
   Retorna `true` si la cola está vacía, y `false` en caso contrario.
   ```cpp
   bool vacia = c.empty(); // vacia es false
   ```

5. **`size()`**:
   Retorna el número de elementos en la cola.
   ```cpp
   int tamano = c.size(); // tamano es 1
   ```

### Ejemplo de uso

Supongamos que tenemos una cola para almacenar enteros. Queremos añadir varios valores, verificar cuál es el primero añadido y luego vaciar la cola.

```cpp
#include <queue>
#include <iostream>

int main() {
    std::queue<int> cola;

    // Agregar elementos
    cola.push(1);
    cola.push(2);
    cola.push(3);

    std::cout << "Tamaño de la cola: " << cola.size() << std::endl;
    std::cout << "Elemento al frente: " << cola.front() << std::endl;

    // Eliminar elementos
    while (!cola.empty()) {
        std::cout << "Eliminando: " << cola.front() << std::endl;
        cola.pop();
    }

    std::cout << "Cola vacía: " << std::boolalpha << cola.empty() << std::endl;
    return 0;
}
```

### Ejemplo práctico: Simulación de una cola de supermercado

Un uso común de la cola es la simulación de líneas de espera. Supongamos que estamos simulando una caja de supermercado en la que los clientes se forman en una cola, y el primero en llegar es el primero en ser atendido.

```cpp
struct Cliente {
    int id;
    int carga; // cantidad de artículos
};

void procesarColaSupermercado(std::queue<Cliente>& cola) {
    while (!cola.empty()) {
        Cliente clienteActual = cola.front();
        std::cout << "Procesando cliente " << clienteActual.id 
                  << " con " << clienteActual.carga << " artículos." << std::endl;
        cola.pop(); // El cliente ha sido procesado
    }
}
```

Este código añade varios clientes a la cola y los procesa en el orden en que llegaron.

```cpp
int main() {
    std::queue<Cliente> supermercado;

    // Agregar clientes a la cola
    supermercado.push({1, 5});
    supermercado.push({2, 3});
    supermercado.push({3, 8});

    // Procesar los clientes
    procesarColaSupermercado(supermercado);

    return 0;
}
```

### Ejemplo visual de una cola

Imaginemos una cola de enteros y las siguientes operaciones:

1. Inicialmente la cola está vacía.
2. Agregamos 1, 2 y 3.
3. Procesamos el primer elemento (1), luego procesamos 2, y finalmente 3.

```cpp
std::queue<int> cola;
cola.push(1); // [1]
cola.push(2); // [1, 2]
cola.push(3); // [1, 2, 3]
cola.pop();   // [2, 3]
cola.pop();   // [3]
cola.pop();   // []
```

---

Este resumen cubre los aspectos esenciales de la clase `queue` y su uso en ejemplos prácticos【5†source】.

id: 24a755f4e24940598ecd070edd26e7b3
parent_id: 8c99ee77d84c400c9c7968dff4a154ec
created_time: 2024-09-19T09:15:14.773Z
updated_time: 2024-09-19T10:51:46.102Z
is_conflict: 0
latitude: 41.38506390
longitude: 2.17340350
altitude: 0.0000
author: 
source_url: 
is_todo: 0
todo_due: 0
todo_completed: 0
source: joplin-desktop
source_application: net.cozic.joplin-desktop
application_data: 
order: 0
user_created_time: 2024-09-19T09:15:14.773Z
user_updated_time: 2024-09-19T10:51:46.102Z
encryption_cipher_text: 
encryption_applied: 0
markup_language: 1
is_shared: 0
share_id: 
conflict_original_id: 
master_key_id: 
user_data: 
deleted_time: 0
type_: 1